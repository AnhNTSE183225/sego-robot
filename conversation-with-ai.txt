> I'm looking to create a UI to define a space using polygons. So let's say I wan to define a 20m x 10m area And inside it, i would define things like point of interests, inner polygons to define as obstacles. Basically it's a UI that allows us to draw up these layouts Do you have any plugins/ dependencies that are used for these kinds of things when creating using React? Or have a sample website that have this?

If you‚Äôre building a UI in React to define a space (e.g., a 20 m √ó 10 m area) and then mark points of interest and inner polygons (‚Äúobstacles‚Äù), here are some libraries, plugins, and sample approaches that can help ‚Äî plus some thoughts on how to pick and use them given your requirements.

‚úÖ Good libraries / plugins

Here are several React-friendly tools which you can use or adapt.

1. react‚Äëdraw‚Äëpolygons

A library for drawing polygons on a canvas, editing them, and retrieving the list of points. 
jsDelivr

Pros: Straightforward for drawing polygons, getting vertex lists, editing.
Cons: Canvas-based; may require extra work to map to ‚Äúreal world‚Äù meters (if you‚Äôre mapping 20 m √ó 10 m).
Use case: If you have a flat 2D plan (not geographical map) this could be a good fit.

2. react‚Äëkonva

Though not specifically ‚Äúpolygon drawing‚Äù only, react-konva provides React bindings for the Konva canvas drawing library, and it supports custom shapes, draggable points, etc. 
konvajs.org
+1

Pros: Great for interactive drawing/editing of shapes (you can drag points, define shapes, move groups).
Cons: You‚Äôll build more of the logic (for creating the ‚Äúarea‚Äù, snapping, etc).
Use case: If you‚Äôre building a more custom UI (e.g., draw area, then drag obstacles inside, define POIs) this gives good flexibility.

3. Using a ‚Äúmap‚Äù-style library with polygon drawing

If your space can be treated like a ‚Äúmap‚Äù (even a simple plan rather than geographic), libraries like mapbox‚Äëgl‚Äëdraw (for Mapbox GL JS) allow polygon drawing and measurement. For example the Mapbox example: ‚ÄúDraw a polygon and calculate its area‚Äù. 
Mapbox
 Also the @react‚Äëgoogle‚Äëmaps/api example using Google‚Äôs drawing library. 
sudolabs.com
+1

Pros: If you think of the layout as ‚Äúmap-like‚Äù, with scale, you get built-in support for drawing, editing, measuring.
Cons: It may bring more overhead (map tiles, geo-coordinate logic) than you need; if your space is simply a fixed dimension UI, a simpler canvas might be better.

4. Smaller niche libraries

For example, react‚Äëpolygon‚Äëdrawer is a small library ‚Äúdraw polygon over any element‚Äù. 
npmjs.com

Use case: If you want minimal features ‚Äî just draw polygon over an image/element.

üîç Which to pick for your use-case?

Given your scenario:

You want to ‚Äúdefine a space of 20 m √ó 10 m‚Äù ‚Üí implies you have a fixed real-world dimension (so you‚Äôll need to map UI units ‚Üî meters).

Inside that, you‚Äôll define ‚Äúpoints of interest‚Äù and ‚Äúinner polygons to define as obstacles‚Äù.

Likely the UI should allow: outline the outer boundary polygon (or rectangle), then draw one or more ‚Äúinner‚Äù polygons (obstacles), and place markers for POIs.

You want a drawing editor (create shapes, drag/resize/move, maybe delete).

Probably easier if the area is treated as a flat 2D plan (not needing map/lat-lng unless you want geospatial).

So:

If your ‚Äúfloor plan‚Äù is a fixed canvas, go with react-konva or react-draw-polygons (canvas/SVG approach).

If you might later scale to geospatial or use zoom/pan and measurement, then maybe use a map/lib that supports drawing polygons (Mapbox / Google Maps APIs).

You will also need conversion between UI units (pixels) and meters (so you either define your canvas to correspond to 20 m √ó 10 m in a fixed scale, or allow user to define boundary and compute scale dynamically).

UI features to implement: draw outer shape, draw inner shapes, drag/move shapes, select POIs, maybe snap to grid, maybe show dimensions.

üìã Sample architectures / steps

Here‚Äôs a sample plan (with React + maybe Typescript) how you could build it:

Setup base canvas/area

Use react-konva: a <Stage> sized to your container, <Layer> inside.

Represent the outer area as a rectangle with known dimensions (e.g., width = 200 pixels = 20 m, height = 100 pixels = 10 m) or some UI scale.

Optionally draw grid lines for user to reference.

Drawing new shapes (obstacles/inner polygons)

On ‚Äúdraw new polygon‚Äù mode: capture user clicks (via Konva onClick or Konva‚Äôs Line shape until closed).

Once polygon closed, convert to a Konva.Polygon or Konva.Line with closed path.

Store list of points (in UI coords) plus convert to ‚Äúreal world‚Äù meters using scale.

Editing shapes

For each polygon/obstacle: allow drag of whole shape (group), or drag of individual vertices (you can render small ‚Äúhandle‚Äù circles at vertices).

Track changes in state (React) so you can serialize shapes, compute collisions, etc.

Points of Interest (POIs)

On ‚Äúadd POI‚Äù mode: click on canvas, place a marker (could be a Circle or icon).

Store point coordinate + metadata (e.g., name, type).

Allow selecting/moving/deleting.

Save/serialization

On save: for each shape get UI coordinates, convert to meters (via known scale).

Output JSON something like:

{
  outerBoundary: [ {x:0,y:0},{x:20,y:0},{x:20,y:10},{x:0,y:10} ],  // in meters
  obstacles: [
    { id:"obs1", vertices: [ ... ] },
    { id:"obs2", vertices: [ ... ] }
  ],
  pointsOfInterest: [
    { id:"poi1", x:5, y:3, metadata: { name:"Door" } },
    ...
  ]
}


UI features

Buttons: ‚ÄúDraw boundary‚Äù, ‚ÄúDraw obstacle‚Äù, ‚ÄúAdd POI‚Äù, ‚ÄúSelect/edit mode‚Äù.

Show dimensions or labels (e.g., show length of side in meters).

Snap-to-grid or guidelines optionally.

Zoom/pan if area large (optional).

Delete shapes.

üß≠ Sample existing websites / demos

The Mapbox ‚ÄúDraw a polygon and calculate its area‚Äù demo is a good reference for user interaction. 
Mapbox

The article ‚ÄúDrawing Interactive Polygon in a React Application‚Äù using react-konva shows how to let users drag and edit shapes. 
Medium

The article on react-google-maps drawing tools shows how controls for polygon drawing can be added. 
sudolabs.com

If you like, I can look up and send you a few full open-source example apps (on GitHub) that implement exactly ‚Äúdrawing/defining area + obstacles + POIs‚Äù in React (so you can clone and adapt). Would you like me to pull those?

> Forgot to add this info to narrow it down: I want it to export out as a .json metadata file with like length, degree and points and stuff, I'd want to design a metadata file like that, and the user can load in and save as and all that kinda stuff

Good, that narrows it a lot. In your case the key is:

Keep your ‚Äútruth‚Äù as a JSON layout object in React state.

Use a drawing lib (like react-konva) only as a view/editor for that JSON.

Implement ‚ÄúExport JSON‚Äù / ‚ÄúImport JSON‚Äù around that layout object.

I‚Äôll break it into:

Recommended stack

Example JSON metadata design

How to wire it into React (save / load)

Where lengths / angles fit in

1. Recommended stack (given JSON requirement)

For a flat 20 m √ó 10 m space, no geographic coordinates:

Rendering & interaction: react-konva

React-friendly

Easy to draw polygons, points, drag vertices, etc.

Data model: your own JSON schema in React state

This is what you export/import.

Konva shapes just read from / write to that state.

You don‚Äôt need Mapbox/Google Maps if you‚Äôre not using lat/lng.

2. Example JSON metadata design

You‚Äôll want:

Global info: units, world size, scale between meters and pixels.

Outer boundary (your 20√ó10 rectangle or arbitrary polygon).

Obstacles (inner polygons).

Points of interest.

Optional: derived stuff like segment lengths and angles.

You can either:

Store only raw points, and compute lengths/angles when needed, or

Store derived values as well (but then you must keep them in sync).

Usually better: store just points, compute lengths/angles on export or on-the-fly.

Example JSON (meters in world space):

{
  "version": 1,
  "meta": {
    "name": "Branch Floor A",
    "description": "Main customer area with robot path obstacles",
    "unit": "meter",
    "worldWidth": 20,
    "worldHeight": 10,
    "origin": "bottom-left", 
    "scale": {
      "metersPerPixel": 0.05
    }
  },
  "boundary": {
    "type": "polygon",
    "clockwise": true,
    "points": [
      { "x": 0, "y": 0 },
      { "x": 20, "y": 0 },
      { "x": 20, "y": 10 },
      { "x": 0, "y": 10 }
    ]
  },
  "obstacles": [
    {
      "id": "obs-1",
      "name": "Waiting chairs",
      "type": "static",
      "clockwise": true,
      "points": [
        { "x": 4, "y": 2 },
        { "x": 8, "y": 2 },
        { "x": 8, "y": 3 },
        { "x": 4, "y": 3 }
      ]
    },
    {
      "id": "obs-2",
      "name": "Column",
      "type": "static",
      "clockwise": true,
      "points": [
        { "x": 12, "y": 5 },
        { "x": 13, "y": 5 },
        { "x": 13, "y": 6 },
        { "x": 12, "y": 6 }
      ]
    }
  ],
  "pointsOfInterest": [
    {
      "id": "poi-1",
      "name": "Entrance",
      "category": "door",
      "x": 0.5,
      "y": 5,
      "headingDeg": 90,
      "metadata": {
        "description": "Main entrance door",
        "robotDockAllowed": false
      }
    },
    {
      "id": "poi-2",
      "name": "Robot dock",
      "category": "dock",
      "x": 18,
      "y": 1,
      "headingDeg": 180,
      "metadata": {
        "power": "220V",
        "maxRobots": 1
      }
    }
  ],
  "paths": [
    {
      "id": "path-1",
      "name": "Robot patrol path",
      "points": [
        { "x": 1, "y": 1 },
        { "x": 10, "y": 1 },
        { "x": 10, "y": 9 },
        { "x": 1, "y": 9 }
      ],
      "segments": [
        {
          "fromIndex": 0,
          "toIndex": 1,
          "length": 9.0,
          "headingDeg": 0
        },
        {
          "fromIndex": 1,
          "toIndex": 2,
          "length": 8.0,
          "headingDeg": 90
        },
        {
          "fromIndex": 2,
          "toIndex": 3,
          "length": 9.0,
          "headingDeg": 180
        }
      ]
    }
  ]
}


Notes:

boundary.points / obstacles[*].points are in meters in a consistent world coordinate system.

clockwise can be useful for navigation/orientation logic.

paths[*].segments could be computed from points (optional to store).

headingDeg is heading from +X axis, counterclockwise, but you can define your own convention.

3. Wiring this into React with react-konva

High-level idea:

Keep a layout state that matches the JSON schema.

For rendering, convert from world coordinates (meters) ‚Üí canvas pixel coordinates.

For editing (dragging points), convert from pixels ‚Üí meters and update layout.

‚ÄúExport‚Äù = JSON.stringify(layout).

‚ÄúImport‚Äù = JSON.parse(fileContents) and setLayout(parsed).

Types (TypeScript-ish)
type Point = { x: number; y: number };

interface Layout {
  version: number;
  meta: {
    name: string;
    description?: string;
    unit: "meter";
    worldWidth: number;
    worldHeight: number;
    origin: "bottom-left" | "top-left";
    scale: {
      metersPerPixel: number;
    };
  };
  boundary: {
    type: "polygon";
    clockwise: boolean;
    points: Point[];
  };
  obstacles: {
    id: string;
    name: string;
    type: "static" | "dynamic";
    clockwise: boolean;
    points: Point[];
  }[];
  pointsOfInterest: {
    id: string;
    name: string;
    category: string;
    x: number;
    y: number;
    headingDeg?: number;
    metadata?: Record<string, unknown>;
  }[];
  paths: {
    id: string;
    name: string;
    points: Point[];
    segments?: {
      fromIndex: number;
      toIndex: number;
      length: number;
      headingDeg: number;
    }[];
  }[];
}

Coordinate conversion
const worldToCanvas = (pt: Point, layout: Layout): Point => {
  const { metersPerPixel } = layout.meta.scale;
  const x = pt.x / metersPerPixel;
  // handle origin convention
  const y =
    layout.meta.origin === "bottom-left"
      ? (layout.meta.worldHeight - pt.y) / metersPerPixel
      : pt.y / metersPerPixel;
  return { x, y };
};

const canvasToWorld = (pt: Point, layout: Layout): Point => {
  const { metersPerPixel } = layout.meta.scale;
  const x = pt.x * metersPerPixel;
  const y =
    layout.meta.origin === "bottom-left"
      ? layout.meta.worldHeight - pt.y * metersPerPixel
      : pt.y * metersPerPixel;
  return { x, y };
};

Export JSON (Save As)
const handleExport = (layout: Layout) => {
  const json = JSON.stringify(layout, null, 2);
  const blob = new Blob([json], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `${layout.meta.name || "layout"}.json`;
  a.click();
  URL.revokeObjectURL(url);
};

Import JSON (Load)
const handleImport = (event: React.ChangeEvent<HTMLInputElement>) => {
  const file = event.target.files?.[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = () => {
    try {
      const parsed: Layout = JSON.parse(reader.result as string);
      setLayout(parsed);
    } catch (e) {
      console.error("Invalid layout JSON", e);
    }
  };
  reader.readAsText(file);
};


You‚Äôd just have a <input type="file" onChange={handleImport} /> somewhere.

Editing a polygon vertex (example)

When the user drags a vertex handle:

const handleVertexDragMove = (
  obstacleId: string,
  vertexIndex: number,
  canvasX: number,
  canvasY: number
) => {
  setLayout((prev) => {
    const layout = structuredClone(prev); // or JSON.parse(JSON.stringify(prev))
    const obs = layout.obstacles.find((o) => o.id === obstacleId);
    if (!obs) return prev;

    const worldPt = canvasToWorld({ x: canvasX, y: canvasY }, layout);
    obs.points[vertexIndex] = worldPt;
    return layout;
  });
};

4. Lengths, degrees, and when to compute them

You mentioned:

‚Äúexport out as a .json metadata file with like length, degree and points and stuff‚Äù

You have two main options:

Derived-only at export time

Store raw points in layout.

When the user clicks ‚ÄúExport JSON‚Äù, you compute segment lengths and angles and attach them temporarily into the exported object.

Internally you don‚Äôt store those values in state ‚Üí less chance of inconsistencies.

Example helper:

const computeSegments = (points: Point[]) => {
  const segments: { fromIndex: number; toIndex: number; length: number; headingDeg: number }[] = [];
  for (let i = 0; i < points.length - 1; i++) {
    const p1 = points[i];
    const p2 = points[i + 1];
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    let headingDeg = (Math.atan2(dy, dx) * 180) / Math.PI; // -180..180
    if (headingDeg < 0) headingDeg += 360;
    segments.push({ fromIndex: i, toIndex: i + 1, length, headingDeg });
  }
  return segments;
};


Store derived fields in JSON

In your Layout, paths[*].segments or obstacles[*].edges store pre-computed lengths/angles.

Keep them updated each time user edits points.

Slightly more work but might be convenient if another system consumes those fields directly.

For robotics / navigation, usually the consuming system can recompute lengths/angles from points, so option 1 is often simpler and safer.

If you want, next step I can sketch a minimal React + react-konva component that:

Shows the 20√ó10 world,

Lets you draw one obstacle polygon,

Lets you place POIs,

And has working ‚ÄúExport JSON‚Äù / ‚ÄúImport JSON‚Äù wired to that schema.